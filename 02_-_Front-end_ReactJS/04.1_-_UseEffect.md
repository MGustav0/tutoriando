# Conexão com o Back-end

Considerarei o código do capítulo 01 e o anterior.

Utilizaremos duas funções do ReactJS para realizar modificações a _useState_ e a _useEffect_. A primeira fora explicada no capítulo 01 e a segunda explicarei neste.

## useEffect

Conforme falado no capítulo 01 em _imutabilidade_, **useEffect** dispara funções sempre que tiver alguma informação alterada, ou dispara uma função assim que o componente for exibido em tela. Ele recebe dois parâmetros no _array de dependências_, o primeiro é qual função se quer disparar e o segundo é quando se quer disparar.

Para diparar toda vez que a variável _projects_ for alterada, preencha o array com ela:

```js
useEffect(() -> {}, [projects]);
```

Para disparar somente uma vez, quando o componente for mostrado, deixe o array vazio:

```js
useEffect(() -> {}, []);
```

Se a informação vier do back-end, então o _useState_ precisa estar vazio para não dar erro e inicializar sem informação. O array vai carregar a variável declarada, no caso, o _projects_.

```js
const [projects, setProjects] = useState([]);
```

Se a informação for um objeto, deve-se inicializar com um objeto vazio: `useState({})`.

### Alterar o estado

Como vimos no capítulo 01, o estado não pode ser alterado, portanto é gerado outro estado e adicionado à função `setProjects()`. Pois não podemos mudar uma variável ou alterar o seu formato, apenas recriá-la com a informação que queremos.

Para alterar o valor de projects, precisa-se chamar a função `setProjects()` dentro da função `handleAddProject()`.

Usa-se o spread operator `...projects` para percorrer o array primário _projects_ e copia-los adicionando os novos valores gerados pelo front-end. Assim o estado é recriado toda vez que adiciona-se novas informações (_projetos_), o estado anterior estará gravado na posição anterior do array.

Note que o primeiro estado não será alterado quando o último estado for adicionado e os anteriores também não serão modificados. O último estado adicionado ao array será renderizado, à medida que o estado é recriado e inserido no array, ele é renderizado.

```js
import React, {useState, useEffect} from 'react';

const [projects, setProjects] = useState([]);

// Array de dependências, parâmetro 1 entre {} e o 2 entre [].
useEffect(() -> {}, []);

function handleAddProject() {
  setProjects([...projects, `Novo Projeto ${Date.now()}`]);
}

return (
  <>
    <ul>
      {projects.map(project => <li key={project}>{project}</li>)}
    </ul>
  </>
)
```

## Receber dados do back-end pelo component

Supondo que o back-end receba as variáveis _tittle_ e _owner_ através da rota _projects_, em uma chamada tipo _post_, podemos enviar essas informações para o front-end adicionando-as ao _useEffect_:

Podemos aproveitar os dados recebidos pela api através da requisição do tipo _GET_ da função `useEffect()`. Assim o _response_ desta função é utilizado na função `handleAddProject()` de forma assíncrona, que espera a informação para utilizá-la.

Após receber os projetos do back-end, envia-se o atual através do `api.post`, que é recuperado na constante _project_, que recebe os dados da resposta _response.data_. Depois é feita a cópia dos projetos _...projects_ e adiciona o projeto atual no final do array.

A informação é cadastrada e toda vez que ela é retornada, é criada uma `<ul>` adicionando na lista.

```js
import React, {useState, useEffect} from 'react';

const [projects, setProjects] = useState([]);

// Recebe a informação do back-end
useEffect(() => {
  api.get('projects'.then(response => {
    // Contém todos os projetos
    setProjects(response.data);
  });
}, []);

async function handleAddProject() {
  // Envia a informação ao back-end
  const response = await api.post('projects', {
    tittle: `New Project-${Date.now()}`,
    owner: "User01",
  });

  // Recebe todos os projetos do back-end pela função useEffect
  const project = response.data;
  // Copia todos os projetos e adiciona o novo projeto no final
  setProjects([...projects, project])
}

return (
  <>
    <ul>
      {projects.map(project => <li key={project}>{project.title}</li>)}
    </ul>
  </>
)
```

Como as `<ul>` são geradas? Veremos logo abaixo.

### Inserir valores no HTML

Para receber o valor total requerido do back-end é necessário colocar o objeto a ser recebido `{project}`, pode-se também receber apenas uma parte dele `{project.title}` na _ul_.

As `<ul>` são geradas com base no tamanho do array, devidamente mapeadas pelo `project.map`, cada ul possui seu próprio identificador, no cas a `key={project}`, e os objetos são recebidos em `{project.title}`.

```js
return (
  <>
    <ul>
      {projects.map(project -> <li key={project}>{project.title}</li>)}
    </ul>
  </>
)
```
